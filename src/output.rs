use anyhow::{Context, Result};
use std::path::Path;
use tokio::fs;
use tracing::{info, debug};
use crate::transcription::TranscriptionResult;

/// Supported output formats
#[derive(Debug, Clone)]
pub enum OutputFormat {
    Text,
    Srt,
    Vtt,
}

impl OutputFormat {
    pub fn from_str(s: &str) -> Result<Self> {
        match s.to_lowercase().as_str() {
            "txt" | "text" => Ok(Self::Text),
            "srt" => Ok(Self::Srt),
            "vtt" | "webvtt" => Ok(Self::Vtt),
            _ => anyhow::bail!("Unsupported output format: {}. Use: txt, srt, vtt", s),
        }
    }
}

/// Save transcription to file in the specified format
pub async fn save_transcription(
    transcription: &TranscriptionResult,
    output_path: &Path,
    format: &str,
) -> Result<()> {
    let format = OutputFormat::from_str(format)
        .context("Invalid output format specified")?;

    let content = match format {
        OutputFormat::Text => format_as_text(transcription),
        OutputFormat::Srt => format_as_srt(transcription),
        OutputFormat::Vtt => format_as_vtt(transcription),
    };

    info!("ðŸ’¾ Saving transcription to {:?} in {:?} format", output_path, format);
    
    fs::write(output_path, content)
        .await
        .context("Failed to write transcription file")?;

    debug!("Transcription saved successfully");
    Ok(())
}

/// Format transcription as plain text
fn format_as_text(transcription: &TranscriptionResult) -> String {
    format!(
        "Wayne Dyer Video Transcription\n\
        ==============================\n\n\
        {}\n\n\
        ---\n\
        Generated by Wayne Transcriber\n\
        Transcribed on: {}\n",
        transcription.full_text,
        chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
    )
}

/// Format transcription as SRT subtitle file
fn format_as_srt(transcription: &TranscriptionResult) -> String {
    let mut srt_content = String::new();
    
    for (index, segment) in transcription.segments.iter().enumerate() {
        srt_content.push_str(&format!(
            "{}\n{} --> {}\n{}\n\n",
            index + 1,
            format_srt_timestamp(segment.start_time),
            format_srt_timestamp(segment.end_time),
            segment.text.trim()
        ));
    }
    
    srt_content
}

/// Format transcription as WebVTT subtitle file
fn format_as_vtt(transcription: &TranscriptionResult) -> String {
    let mut vtt_content = String::from("WEBVTT\n\n");
    
    for segment in &transcription.segments {
        vtt_content.push_str(&format!(
            "{} --> {}\n{}\n\n",
            format_vtt_timestamp(segment.start_time),
            format_vtt_timestamp(segment.end_time),
            segment.text.trim()
        ));
    }
    
    vtt_content
}

/// Format timestamp for SRT format (HH:MM:SS,mmm)
fn format_srt_timestamp(seconds: f64) -> String {
    let total_seconds = seconds as u64;
    let hours = total_seconds / 3600;
    let minutes = (total_seconds % 3600) / 60;
    let secs = total_seconds % 60;
    let milliseconds = ((seconds - total_seconds as f64) * 1000.0) as u32;
    
    format!("{:02}:{:02}:{:02},{:03}", hours, minutes, secs, milliseconds)
}

/// Format timestamp for WebVTT format (HH:MM:SS.mmm)
fn format_vtt_timestamp(seconds: f64) -> String {
    let total_seconds = seconds as u64;
    let hours = total_seconds / 3600;
    let minutes = (total_seconds % 3600) / 60;
    let secs = total_seconds % 60;
    let milliseconds = ((seconds - total_seconds as f64) * 1000.0) as u32;
    
    format!("{:02}:{:02}:{:02}.{:03}", hours, minutes, secs, milliseconds)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::transcription::TranscriptionSegment;

    fn create_test_transcription() -> TranscriptionResult {
        TranscriptionResult {
            segments: vec![
                TranscriptionSegment {
                    start_time: 0.0,
                    end_time: 5.5,
                    text: "Welcome to this Wayne Dyer presentation.".to_string(),
                },
                TranscriptionSegment {
                    start_time: 6.0,
                    end_time: 12.3,
                    text: "Today we'll explore the power of intention.".to_string(),
                },
            ],
            full_text: "Welcome to this Wayne Dyer presentation. Today we'll explore the power of intention.".to_string(),
        }
    }

    #[test]
    fn test_srt_timestamp_formatting() {
        assert_eq!(format_srt_timestamp(0.0), "00:00:00,000");
        assert_eq!(format_srt_timestamp(5.5), "00:00:05,500");
        assert_eq!(format_srt_timestamp(125.750), "00:02:05,750");
        assert_eq!(format_srt_timestamp(3661.250), "01:01:01,250");
    }

    #[test]
    fn test_vtt_timestamp_formatting() {
        assert_eq!(format_vtt_timestamp(0.0), "00:00:00.000");
        assert_eq!(format_vtt_timestamp(5.5), "00:00:05.500");
        assert_eq!(format_vtt_timestamp(125.750), "00:02:05.750");
    }

    #[test]
    fn test_srt_formatting() {
        let transcription = create_test_transcription();
        let srt = format_as_srt(&transcription);
        
        assert!(srt.contains("1\n00:00:00,000 --> 00:00:05,500"));
        assert!(srt.contains("Welcome to this Wayne Dyer presentation."));
        assert!(srt.contains("2\n00:00:06,000 --> 00:00:12,300"));
        assert!(srt.contains("Today we'll explore the power of intention."));
    }

    #[test] 
    fn test_vtt_formatting() {
        let transcription = create_test_transcription();
        let vtt = format_as_vtt(&transcription);
        
        assert!(vtt.starts_with("WEBVTT\n\n"));
        assert!(vtt.contains("00:00:00.000 --> 00:00:05.500"));
        assert!(vtt.contains("Welcome to this Wayne Dyer presentation."));
    }
}
